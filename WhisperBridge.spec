# -*- mode: python ; coding: utf-8 -*-
# Dynamic build spec: OCR-enabled or OCR-disabled based on BUILD_OCR_ENABLED flag

import os
import sys
import fnmatch
from PyInstaller.utils.hooks import collect_all
from PyInstaller.building.build_main import Analysis, PYZ, EXE, COLLECT
from PyInstaller.building.datastruct import TOC

block_cipher = None

# Paths (avoid __file__ as it may be undefined; rely on CWD where PyInstaller is invoked)
project_root = os.getcwd()

pathex = [os.path.join(project_root, 'src')]


# Bundle app assets (icons, qss) under whisperbridge/assets
assets_src = os.path.join(project_root, 'src', 'whisperbridge', 'assets')

# Collect minimal package data (qtawesome fonts/icons)
qtawesome_data, qtawesome_bins, qtawesome_hidden = collect_all('qtawesome')

hiddenimports = [
    # Minimal HTTP stack for OpenAI (httpx -> httpcore -> h11)
    'httpx._transports.default',
    'httpcore._sync',
    'h11',
    # Pydantic Core native ext used by OpenAI client models
    'pydantic_core._pydantic_core',
    'keyring',
    'keyring.backends.Windows',
]

# Normalize datas to (src, dest) tuples
def _norm_datas(items):
    out = []
    for it in items:
        if isinstance(it, (list, tuple)) and len(it) >= 2:
            out.append((it[0], it[1]))
    return out

datas = []
datas += _norm_datas(qtawesome_data)
# App assets
datas += [(assets_src, 'whisperbridge/assets')]

# Include build flags if available (generated by build.py)
build_flags_path = os.path.join(project_root, 'build', 'flags', '_build_flags.py')
if os.path.exists(build_flags_path):
    datas += [(build_flags_path, '_build_flags.py')]
    print(f"[WhisperBridge.spec] Including _build_flags.py from {build_flags_path}")
else:
    print("[WhisperBridge.spec] _build_flags.py not found - using runtime env var fallback")

binaries = []
# Only qtawesome binaries (fonts may appear here depending on environment)
binaries += qtawesome_bins

# Dynamic configuration based on build flags
# Set by build.py based on user choice
try:
    # New flag name (preferred)
    from _build_flags import BUILD_OCR_ENABLED, BUILD_MODE, USE_UPX  # type: ignore

    ocr_enabled = bool(BUILD_OCR_ENABLED)
    build_mode = BUILD_MODE
    use_upx = USE_UPX
    ocr_source = 'BUILD_FLAGS'
except ImportError:
    # Env fallbacks:
    # - WHISPERBRIDGE_BUILD_OCR (new)
    # - OCR_ENABLED (legacy compatibility)
    _raw_ocr = os.environ.get('WHISPERBRIDGE_BUILD_OCR')
    if _raw_ocr is None:
        _raw_ocr = os.environ.get('OCR_ENABLED', '1')

    ocr_enabled = str(_raw_ocr).strip().lower() in ('1', 'true', 'yes', 'y', 'on')
    build_mode = os.environ.get('BUILD_MODE', 'onedir')
    use_upx = os.environ.get('USE_UPX', '1') == '1'
    ocr_source = 'ENV'

# Simple logging
print("========== WhisperBridge.spec BUILD CONFIG ==========")
print(f"[WhisperBridge.spec] BUILD_OCR_ENABLED: {ocr_enabled} (source: {ocr_source})")
print(f"[WhisperBridge.spec] BUILD_MODE: {build_mode}")
print(f"[WhisperBridge.spec] USE_UPX: {use_upx}")
print("=====================================================")

if ocr_enabled:
    # OCR-enabled build: minimal excludes (keep OCR/ML stacks)
    excludes = [
        # Unused Qt modules (keep only Core/Gui/Widgets/Concurrent if actually used)
        'PySide6.Qt3DCore',
        'PySide6.Qt3DRender',
        'PySide6.Qt3DInput',
        'PySide6.QtCharts',
        'PySide6.QtDataVisualization',
        'PySide6.QtMultimedia',
        'PySide6.QtMultimediaWidgets',
        'PySide6.QtNetworkAuth',
        'PySide6.QtNfc',
        'PySide6.QtPositioning',
        'PySide6.QtPrintSupport',
        'PySide6.QtQml',
        'PySide6.QtQuick',
        'PySide6.QtQuickControls2',
        'PySide6.QtQuickWidgets',
        'PySide6.QtRemoteObjects',
        'PySide6.QtSensors',
        'PySide6.QtSerialPort',
        'PySide6.QtSql',
        'PySide6.QtStateMachine',
        'PySide6.QtSvg',
        'PySide6.QtTest',
        'PySide6.QtTextToSpeech',
        'PySide6.QtWebChannel',
        'PySide6.QtWebEngineCore',
        'PySide6.QtWebEngineQuick',
        'PySide6.QtWebEngineWidgets',
        'PySide6.QtWebSockets',
        'PySide6.QtXml',
        'PySide6.QtXmlPatterns',
        'PySide6.QtHelp',
        'PySide6.QtLocation',
        'PySide6.QtBluetooth',
        'PySide6.QtConcurrent',
        'PySide6.QtDBus',
        'PySide6.QtOpenGL',
        'PySide6.QtOpenGLWidgets',
        # Google/Cloud stacks (OpenAI-only slim)
        'google.cloud',
    ]

    # OCR-enabled DROP_DIR_CONTAINS (keep OCR/ML stacks)
    DROP_DIR_CONTAINS = [
        '/pyside6/translations/',
        '/qt/translations/',
        '/pyside6/qml/',
        '/qt/qml/',
        '/site-packages/google/',
        '/googleapiclient/',
        #'grpc/_cython/_credentials',
        '/tzdata/',
        '/mypy/',
        '/pydantic-2.12.4.dist-info/',
        '/markupsafe-3.0.3.dist-info/',
        '/qtawesome-1.4.0.dist-info/',
        '/setuptools-80.9.0.dist-info/',
        '/PySide6/plugins/imageformats',
    ]

    # OCR-enabled DROP_BIN_BASENAMES
    DROP_BIN_BASENAMES = {
        'qt6network.dll',
        'qt6opengl.dll',
        'qt6openglwidgets.dll',
        'qt6quick.dll',
        'qt6virtualkeyboard.dll',
        'qtnetwork.pyd',
        'opengl32sw.dll',
        'qt6pdf.dll',
        '_avif.cp313-win_amd64.pyd',
        'Qt6Svg.dll',
        '_avif.cp312-win_amd64.pyd',
        '_imagingft.cp312-win_amd64.pyd',
    }

else:
    # OCR-disabled build: exclude OCR/ML stacks
    excludes = [
        # Unused Qt modules (keep only Core/Gui/Widgets/Concurrent if actually used)
        'PySide6.Qt3DCore',
        'PySide6.Qt3DRender',
        'PySide6.Qt3DInput',
        'PySide6.QtCharts',
        'PySide6.QtDataVisualization',
        'PySide6.QtMultimedia',
        'PySide6.QtMultimediaWidgets',
        'PySide6.QtNetworkAuth',
        'PySide6.QtNfc',
        'PySide6.QtPositioning',
        'PySide6.QtPrintSupport',
        'PySide6.QtQml',
        'PySide6.QtQuick',
        'PySide6.QtQuickControls2',
        'PySide6.QtQuickWidgets',
        'PySide6.QtRemoteObjects',
        'PySide6.QtSensors',
        'PySide6.QtSerialPort',
        'PySide6.QtSql',
        'PySide6.QtStateMachine',
        'PySide6.QtSvg',
        'PySide6.QtTest',
        'PySide6.QtTextToSpeech',
        'PySide6.QtWebChannel',
        'PySide6.QtWebEngineCore',
        'PySide6.QtWebEngineQuick',
        'PySide6.QtWebEngineWidgets',
        'PySide6.QtWebSockets',
        'PySide6.QtXml',
        'PySide6.QtXmlPatterns',
        'PySide6.QtHelp',
        'PySide6.QtLocation',
        'PySide6.QtBluetooth',
        'PySide6.QtConcurrent',
        'PySide6.QtDBus',
        'PySide6.QtOpenGL',
        'PySide6.QtOpenGLWidgets',

        # Google/Cloud stacks (OpenAI-only slim)
        'google.cloud',
    ]

    # OCR-disabled DROP_DIR_CONTAINS (exclude OCR/ML stacks)
    DROP_DIR_CONTAINS = [
        '/pyside6/translations/',
        '/qt/translations/',
        '/pyside6/qml/',
        '/qt/qml/',
        '/site-packages/google/',
        '/googleapiclient/',
    ]

    # OCR-disabled DROP_BIN_BASENAMES
    DROP_BIN_BASENAMES = {
        'qt6network.dll',
        'qt6opengl.dll',
        'qt6openglwidgets.dll',
        'qt6quick.dll',
        'qt6virtualkeyboard.dll',
        'qtnetwork.pyd',
        'opengl32sw.dll',
        'qt6pdf.dll',
        '_avif.cp313-win_amd64.pyd',
    }

# Common DROP_BIN_GLOBS for both builds
DROP_BIN_GLOBS = [
    'qt6qml*.dll',
    'qt6quick*.dll',
    'qt6opengl*.dll',
    'qt6virtualkeyboard*.dll',
]

a = Analysis(
    [os.path.join(project_root, 'src', 'main.py')],
    pathex=pathex,
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    runtime_hooks=[],
    excludes=excludes,
    noarchive=False,
)

# Prune PySide6 translations, QML, and unwanted Qt binaries
def _normpath(p):
    return str(p).replace('\\', '/').lower()

# Whitelist for Qt plugin folders (everything else in plugins/ будет удалено)
KEEP_QT_PLUGIN_DIRS = {'platforms', 'imageformats', 'styles', 'iconengines'}

def _entry_paths(entry):
    try:
        src = entry[0]
        dest = entry[1] if len(entry) > 1 else ''
    except Exception:
        return '', ''
    return _normpath(src), _normpath(dest)

def _is_qt_translation(entry):
    ns, nd = _entry_paths(entry)
    return '/qt/translations/' in ns or '/qt/translations/' in nd or (ns.endswith('.qm') and '/translations/' in ns)

def _is_drop_dir(entry):
    ns, nd = _entry_paths(entry)
    for sub in DROP_DIR_CONTAINS:
        if sub in ns or sub in nd:
            return True
    return False

def _is_unwanted_qt_plugin(entry):
    ns, nd = _entry_paths(entry)
    path = ns if '/plugins/' in ns else (nd if '/plugins/' in nd else '')
    if not path:
        return False
    plugin_sub = path.split('/plugins/', 1)[1]
    top = plugin_sub.split('/', 1)[0] if '/' in plugin_sub else plugin_sub
    return top not in KEEP_QT_PLUGIN_DIRS

def _is_unwanted_qt_binary(entry):
    ns, nd = _entry_paths(entry)
    base = os.path.basename(ns)
    if base in DROP_BIN_BASENAMES:
        return True
    for pat in DROP_BIN_GLOBS:
        if fnmatch.fnmatch(base, pat):
            return True
    # Safety: дополнительно срежем семейство QML
    if base.startswith('qt6qml'):
        return True
    return _is_unwanted_qt_plugin(entry)

# Пересобираем TOC, убирая переводы, лишние Qt-либы и каталоги по маскам
a.datas = TOC([x for x in a.datas if not (_is_qt_translation(x) or _is_drop_dir(x))])
a.binaries = TOC([x for x in a.binaries if not (_is_unwanted_qt_binary(x) or _is_drop_dir(x))])
a.zipfiles = TOC([x for x in a.zipfiles if not _is_drop_dir(x)])

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

# Build mode configuration - single unified EXE object
# Set parameters based on build_mode
console_mode = build_mode == 'onedir_console'
onefile_mode = build_mode == 'onefile'

if onefile_mode:
    # One-file mode: EXE contains everything, no COLLECT needed
    exe = EXE(
        pyz,
        a.scripts,
        a.binaries,
        a.zipfiles,
        a.datas,
        name='WhisperBridge',
        debug=False,
        bootloader_ignore_signals=False,
        strip=False,
        upx=use_upx,
        console=console_mode,
        onefile=True,
        icon=os.path.join(project_root, 'src', 'whisperbridge', 'assets', 'icons', 'app_icon.png'),
    )
else:
    # One-dir mode: create a 'thin' EXE and a COLLECT object for all other files
    exe = EXE(
        pyz,
        a.scripts,
        [],  # Binaries handled by COLLECT
        [],  # Zipfiles handled by COLLECT
        [],  # Datas handled by COLLECT
        exclude_binaries=True,
        name='WhisperBridge',
        debug=False,
        bootloader_ignore_signals=False,
        strip=False,
        upx=use_upx,
        console=console_mode,
        onefile=False,
        icon=os.path.join(project_root, 'src', 'whisperbridge', 'assets', 'icons', 'app_icon.png'),
    )
    collect = COLLECT(
        exe,
        a.binaries,
        a.zipfiles,
        a.datas,
        strip=False,
        upx=use_upx,
        upx_exclude=[],
        name='WhisperBridge'
    )